# -*- coding: utf-8 -*-
"""
/***************************************************************************
 derogation
                                 A QGIS plugin
 Ce plugin est compose de 2 parties : La premiere partie concerne l'implementation des bidonvilles, il aide ainsi a faciliter la prise de decision pour faire la derogation.  La deuxieme partie consiste a automatiser le telechargement et le traitement des images Sentinel-1.  
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-22
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Abdellaoui Houda- Laghrissi Chafik
        email                : abdellaouihouda2@gmail,com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from pathlib import Path
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon, QColor, QCursor
from qgis.PyQt.QtWidgets import QAction, QTableWidgetItem
from qgis.core import *
from qgis.core import (QgsProject, QgsVectorLayer,
                       QgsFeature, QgsRasterLayer, QgsGeometry)
from qgis.gui import *
from qgis.gui import QgsMessageBar
from pylab import *
import processing
import sys
import csv
from .User import User

from .resources import *
# Initialize Qt resources from file resources.py
# Import the code for the dialog
from .derogation_processing_dialog import derogationDialog
import os.path
current_user: User


class derogation:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'derogation_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Derogation_imgprocessing')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('derogation', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/derogation_processing/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Derogation_imgprocessing'),
                action)
            self.iface.removeToolBarIcon(action)

    def layer_name(self, name: str):
        return QgsProject.instance().mapLayersByName(name)[0]

    def zone_interet(self):
        global layer
        global layer_list

        canvas = self.iface.mapCanvas()
        mapRenderer = canvas.mapSettings()
        crs = mapRenderer.destinationCrs()
        # bufferLayer = QgsVectorLayer("Point?crs="+str(crs.toWkt()), "point de interet", "memory")

        x = self.dlg.x_projet.text()
        y = self.dlg.y_projet.text()
        # Specify the geometry type
        # layer = QgsVectorLayer('Point?crs=user:100000', 'point de interet' , 'memory')
        layer = QgsVectorLayer("Point?crs=EPSG:3857" +
                               str(crs.toWkt()), "Nouveau Projet", "memory")
        prov = layer.dataProvider()
        point = QgsPointXY(float(x), float(y))
        feat = QgsFeature()
        feat.setGeometry(QgsGeometry.fromPointXY(point))
        prov.addFeatures([feat])
        layer.updateExtents()
        QgsProject.instance().addMapLayers([layer])
        layers = [tree_layer.layer()
                  for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]

        # layers = self.iface.legendInterface().layers()

        layer_list = []
        self.dlg.combo_choose.clear()
        for layer in layers:
            layer_list.append(layer.name())
        self.dlg.combo_choose.addItems(layer_list)

    def buffer(self):

        global layer_list
        global layers

        canvas = self.iface.mapCanvas()
        mapRenderer = canvas.mapSettings()
        crs = mapRenderer.destinationCrs()
        self.iface.activeLayer()
        # progress = self.dlg.progressBar
        # progress.setMaximum(100)
        tam = self.dlg.buffer_radius.text()
        # tam = '10000'
        distance = self.dlg.combo_choose.currentIndex()
        layer_buff = QgsVectorLayer(
            "Polygon?crs=EPSG:3857" + str(crs.toWkt()), "Buffer", "memory")
        pr = layer_buff.dataProvider()
        for elem in self.FindLayerByName("Nouveau Projet").getFeatures():
            geom = elem.geometry()
            buffer = geom.buffer(float(tam), 10)
            poly = buffer.asPolygon()
            seg = QgsFeature()
            seg.setGeometry(QgsGeometry.fromPolygonXY(poly))
            pr.addFeatures([seg])
            layer_buff.updateExtents()
            layer_buff.setOpacity(0.4)
            # zooms to layer
        self.iface.actionZoomToLayer().trigger()
        # Ajout de la couche
        # count = layer_buff.selectedFeatureCount()
        # i = 0
        # for feature in layer_buff.selectedFeatures():
        #     i = i + 1
        #     percent = (i / float(count)) * 100
        #     progress.setValue(percent)
        #     time.sleep(1)
        QgsProject.instance().addMapLayers([layer_buff])
        layer_buff.isValid()

        layers = [tree_layer.layer()
                  for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
        # layers = self.iface.legendInterface().layers()
        layer_list = []
        self.dlg.combo_choose.clear()
        for layer in layers:
            layer_list.append(layer.name())
        self.dlg.combo_choose.addItems(layer_list)

    # def table_attri(self):
    #
    #     table = self.dlg.map_display
    #     canvas = self.iface.mapCanvas()
    #     areas = []
    #
    #     line_layer = self.FindLayerByName('Buffer')
    #     QgsMessageLog.logMessage(str(line_layer))
    #     area_layer = self.FindLayerByName(self.dlg.combo_choose.currentText())
    #     QgsMessageLog.logMessage(str(area_layer))
    #
    #     prov = area_layer.dataProvider()
    #     fields = prov.fields()
    #     table.setColumnCount(7)
    #     table.setRowCount(1)
    #     i = 0
    #     for field in fields:
    #         if field.name() == "OBJECTID" or field.name() == "REGIME_FON" or field.name() == "REFERENCE_" or field.name() == "CERCLE" or field.name() == "COMMUNE" or field.name() == "STATUT_FON" or field.name() == "SUPERFICIE":
    #             self.dlg.map_display.setHorizontalHeaderItem(i, QTableWidgetItem(field.name()))
    #             i = i + 1
    #
    #     varcheck = 0
    #     for line_feature in line_layer.getFeatures():
    #         i = 0
    #         for area_feature in area_layer.getFeatures():
    #             QgsMessageLog.logMessage(str(area_feature.geometry().intersects(line_feature.geometry())))
    #             if (area_feature.geometry().intersects(line_feature.geometry())==True):
    #                 varcheck = 1
    #                 areas.append(area_feature.id())
    #                 area_feature.geometry().area()
    #                 table.insertRow(i + 1)
    #                 j = 0
    #                 k = 0
    #                 for field in fields:
    #                     if field.name() == "OBJECTID" or field.name() == "REGIME_FON" or field.name() == "REFERENCE_" or field.name() == "CERCLE" or field.name() == "COMMUNE" or field.name() == "STATUT_FON" or field.name() == "SUPERFICIE":
    #                         s = ''
    #                         s = str(area_feature.attributes()[j])
    #                         QMessageBox.information(None, "DEBUG:", str(s))
    #                         table.setItem(i, k, QTableWidgetItem(s))
    #                         k = k + 1
    #                     j = j + 1
    #
    #                 i = i + 1
    #         table.removeRow(i)
    #
    #         if not varcheck:
    #             self.iface.messageBar().pushMessage("Problème : ","Désolés, pas d'intersection entre la couche choisie et alentour de point d'interet.Merci")
    #
    #         # legend = self.iface.legendInterface()
    #     layers = [tree_layer.layer() for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
    #
    #     for layer in canvas.layers():
    #         if layer.type() == layer.VectorLayer:
    #             layer.removeSelection()
    #             QgsProject.instance().layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(True)
    #     canvas.refresh()
    #     QgsProject.instance().layerTreeRoot().findLayer(area_layer.id()).setItemVisibilityChecked(True)
    #     QgsProject.instance().layerTreeRoot().findLayer(line_layer.id()).setItemVisibilityChecked(True)
    #         # legend.setLayerVisible(area_layer, True)
    #         # legend.setLayerVisible(line_layer, True)
    #         # project=self.FindLayerByName('Couche_Projet')
    #         # legend.setLayerVisible(project, True)
    #     area_layer.select(areas)
    #     cLayer = self.iface.mapCanvas().currentLayer()
    #     indexes = table.selectionModel().selectedRows()
    #     cLayer.removeSelection()
    #     for index in sorted(indexes):
    #         print('Row %d is selected' % index.row())
    #         cLayer.select(index.row())
    #         canvas.zoomToSelected()
    #     table.itemSelectionChanged.connect(self.afficher_zoom)

    def afficher_inter(self, row_data, row_number):

        self.dlg.map_display.insertRow(row_number)
        column = 0
        for column_number, data in enumerate(row_data.attributes()):
            if column_number in [0, 3, 7, 10]:
                self.dlg.map_display.setItem(
                    row_number, column, QTableWidgetItem(str(data)))
                column += 1

    def ajouter_table(self):
        canvas = self.iface.mapCanvas()
        w = self.FindLayerByName(self.dlg.combo_choose.currentText())
        v = self.FindLayerByName('Buffer')

        self.dlg.map_display.setRowCount(0)
        field_names = [field.name() for num, field in enumerate(
            w.pendingFields()) if num in [0, 3, 7, 10]]
        self.dlg.map_display.setHorizontalHeaderLabels(field_names)

        row_number = 0
        for a in w.getFeatures():
            for b in v.getFeatures():
                if a.geometry().intersects(b.geometry()):
                    geom = a.geometry().QgsProject.instance().addMapLayer(layer1)(b.geometry())
                    self.afficher_inter(geom, row_number)
                    row_number += 1

    def afficher_zoom(self):

        table = self.dlg.map_display

        canvas = self.iface.mapCanvas()
        cLayer = self.iface.mapCanvas().currentLayer()
        indexes = table.selectionModel().selectedRows()
        cLayer.removeSelection()
        for index in sorted(indexes):
            print('Row %d is selected' % index.row())
            cLayer.select(index.row())
            canvas.zoomToSelected()

    def intersection(self):
        v = self.FindLayerByName('Buffer')
        poly = self.FindLayerByName(self.dlg.combo_choose.currentText())

        # intersec = QgsVectorLayer("Polygon?crs=EPSG:3857%field= Projets:string(25)&field=Status:string(25)&field = Surface:string(25)&field=Surface intersectee:string(25)",'Intersectiooons',"memory")
        # intersec_data = intersec.dataProvider()
        # intersec.startEditing()
        #
        # selectionsid = []
        # selectionstatus = []
        # selectionsurface = []
        # selectionsintersurface = []
        # buffer_features = v.getFeatures()
        # p_features =poly.getFeatures()
        #
        # for bf in buffer_features:
        #     for p in p_features:
        #         if bf.geometry().intersects(p.geometry()):
        #             feature_int = QgsFeature()
        #             selectionsid.append(p.id())
        #             selectionstatus.append(poly.name())
        #             surface = int(poly.fields().lookupField("SUPERFICIE"))
        #             selectionsurface.append(p.attributes()[surface])
        #             intersection_result = bf.geometry().intersection(p.geometry())
        #             selectionsintersurface.append(intersection_result.area())
        #             feature_int.setAttributes([p.id(), poly.name(), p.attributes()[surface],bf.geometry().intersection(p.geometry()).area()])
        #             feature_int.setGeometry(intersection_result)
        #             print("yesss")
        #             intersec_data.addFeatures([feature_int])
        #             poly.selectByIds(selectionsid)
        #             self.iface.mapCanvas().zoomToSelected(v)
        #
        # intersec.commitChanges()
        # intersec.updateExtents()

        # for a in v.getFeatures():
        #     for b in poly.getFeatures():
        #         if a.geometry().intersects(b.geometry()):
        #             fet= QgsFeature()
        #             selectionsid.append(b.id())
        #             selectionstatus.append(b.name())
        #             surface =

        # intersections = []
        # for a in v.getFeatures():
        #     for b in poly.getFeatures():
        #         if a.geometry().intersects(b.geometry()):
        #             feat = QgsFeature()
        #
        #             intersection = a.geometry().intersection(b.geometry())
        #
        #             layer1 = QgsVectorLayer(intersection)
        #             layer1.addFeatures(intersection)
        #
        # QgsProject.instance().addMapLayer(intersections)
        # # # QgsProject.instance().addMapLayer(a)
        # self.iface.actionZoomToSelected().trigger()
        # print(a)

        # buffer:layer = QgsVectorLayer(v,"Buffffers","ogr")
        # QgsProject.instance().addMapLayer(buffer_layer,False)
        #
        # parameter= {'INPUT':QgsProcessingFeatureSourceDefinition(buffer_layer.id(), True),
        #       'OUTPUT': 'memory:'}
        # poly_layer = processing.run()

        # buffer_layer = self.iface.addVectorLayer(v,'buffer','ogr')
        # intersection_lay = self.iface.addVectorLayer(poly,'intersected','ogr')
        #
        # for i in range(5):
        #     intersection_lay.select(i)
        #     params={
        #         'INPUT':buffer_layer,
        #         'PREDICATE':0,
        #         'INTERSECT':QgsProcessingFeatureSourceDefinition(intersection_lay.id(), True),
        #         'METHOD':0}
        #     result = processing.run("qgis:selectbylocation",params)
        # for a in v.getFeatures():
        #     for b in poly.getFeatures():
        #         if a.geometry().intersects(b.geometry()):
        #             print(a.id(),",",b.id())
        #             poly.select(b.id())
        #             self.iface.actionZoomToSelected().trigger()
        #
        # a1 = QgsProject.instance().mapLayersByName('Buffer')[0]
        # a2 = QgsProject.instance().mapLayersByName(str(str(self.dlg.combo_choose.currentText()))[0])
        # # processing.runandload("qgis:intersection",a1,a2,"memory:myCut")

        canvas = self.iface.mapCanvas()
        mapRenderer = canvas.mapSettings()
        crs = mapRenderer.destinationCrs()
        self.iface.activeLayer()

        # layer_buff = QgsVectorLayer("Polygon?crs=EPSG:3857" + str(crs.toWkt()), "Buffer", "memory")

        layer = QgsVectorLayer("Polygon?crs=EPSG:3857" +
                               str(crs.toWkt()), "Intersections", "memory")
        QgsProject.instance().addMapLayer(layer, False)

        a = processing.run("qgis:intersection", {
            "INPUT": poly,
            "PREDICATE": 0,
            "OVERLAY": v,
            "METHOD": 0,
            "OUTPUT": 'TEMPORARY_OUTPUT'})
        print(a)

        layer = a['OUTPUT']
        layer.commitChanges()
        layer.updateExtents()
        self.iface.actionZoomToLayer()

    # def genererPDF(self):
    #     mapRenderer = iface.mapCanvas().mapSettings()
    #     c = QgsComposition(mapRenderer)
    #     c.setPlotStyle(QgsComposition.Print)
    #     c. setPrintResolution(300)
    #     w,h =c.paperWidth(), c.paperHeight()
    #     composerMap = QgsComposerMap(c,0,0,w,h)
    #     c.addItem(composerMap)

    def FindLayerByName(self, NameLayer):
        couche = None
        for ch in QgsProject.instance().mapLayers().values():
            if ch.name() == NameLayer:
                couche = ch
                break
        return couche

    # DILIGUIIIIIII THE  CODE FOR THE SECOND PART STARTS HERE

    def go_to_page(self, index):
        self.dlg.tabWidget.setCurrentIndex(index)

    def handle_sign_up(self):
        user_name = self.dlg.username.text()
        password = self.dlg.password.text()
        password_confirm = self.dlg.password_confirm.text()
        global current_user
        current_user = User(user_name, password)
        if (password == password_confirm):
            current_user.sign_up()
            self.dlg.tabWidget.setCurrentIndex(2)
        else:
            self.dlg.confirm_error.setText("invalid password")

    def setter():
        pass

    def handle_login(self):

        global current_user
        self.dlg.password_error_2.clear()
        user_name = self.dlg.username_input.text()
        password = self.dlg.password_input.text()
        current_user = User(user_name, password)
        try:
            if current_user:
                current_user.login()
            if current_user.token:
                self.dlg.input_lat.setText(
                    str(current_user.config["latitude"]))
                self.dlg.input_lon.setText(
                    str(current_user.config["longitude"]))
                self.dlg.tabWidget.setCurrentIndex(3)
            else:
                self.dlg.confirm_error2.setText("invalid credentials")
        except NameError:
            current_user = User(user_name, password)
            current_user.login()
            if current_user.token:
                self.dlg.tabWidget.setCurrentIndex(3)
                self.dlg.input_lat.setText(
                    str(current_user.config["latitude"]))
                self.dlg.input_lon.setText(
                    str(current_user.config["longitude"]))
            else:
                self.dlg.password_error_2.setText("invalid credentials")
        except Exception as ex:
            self.dlg.password_error_2.setText("invalid credentials")
            print(ex)

    def handle_update(self):
        satellite = self.dlg.comboBox.currentText()
        longitude = self.dlg.input_lon.text()
        latitude = self.dlg.input_lat.text()
        global current_user
        current_user.update_user_config({
            "satellite": satellite, "longitude": float(longitude), "latitude": float(latitude)
        })

        current_user.get_images()
        self.dlg.tabWidget.setCurrentIndex(4)
        # tabulation
        for image in current_user.images:
            rowPosition = self.dlg.available_imgs.rowCount()
            self.dlg.available_imgs.insertRow(rowPosition)
            id = QTableWidgetItem(str(image["id"]))
            self.dlg.available_imgs.setItem(rowPosition, 0, id)
            title = QTableWidgetItem(image['name'])
            self.dlg.available_imgs.setItem(rowPosition, 1, title)
            downloaded = QTableWidgetItem(str(image["is_downloaded"]))
            self.dlg.available_imgs.setItem(rowPosition, 2, downloaded)

        # end
    # download data
    def handle_download(self):
        path = os.path.join(QgsProject.instance().homePath(), 'satdata')
        global current_user
        Path(path).mkdir(parents=True, exist_ok=True)
        image_name = current_user.images[0]["name"]
        path = current_user.download_image(image_name, path)
        downloaded_images = [
            image for image in current_user.images if image["is_downloaded"] == True]
        for image in downloaded_images:
            rowPosition = self.dlg.downloaded_imgs.rowCount()
            id = QTableWidgetItem(str(image["id"]))
            self.dlg.downloaded_imgs.setItem(rowPosition, 0, id)
            title = QTableWidgetItem(image['name'])
            self.dlg.downloaded_imgs.setItem(rowPosition, 1, title)
            downloaded = QTableWidgetItem(str(image["is_downloaded"]))
            self.dlg.downloaded_imgs.setItem(rowPosition, 2, downloaded)
        im = QgsRasterLayer(path, image_name, 'ogr')
        QgsProject.instance().addMapLayer(im)

    def buttons(self):
        self.dlg.btn_valider.clicked.connect(
            self.handle_sign_up
        )
        self.dlg.btn_continuer.clicked.connect(self.handle_login)
        self.dlg.settings.clicked.connect(
            lambda: self.dlg.tabWidget.setCurrentIndex(3))
        self.dlg.btn_valider_2.clicked.connect(self.handle_update)
        self.dlg.sign_up_btn.clicked.connect(
            lambda: self.dlg.tabWidget.setCurrentIndex(1))
        self.dlg.download.clicked.connect(self.handle_download)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = derogationDialog()
            layers = [tree_layer.layer() for tree_layer in QgsProject.instance(
            ).layerTreeRoot().findLayers()]
            layer_list = []
            for layer in layers:
                layer_list.append(layer.name())
            self.dlg.combo_choose.addItems(layer_list)

        # show the dialog
        self.dlg.show()

        self.dlg.create_btn.clicked.connect(self.zone_interet)
        self.dlg.analyze_btn.clicked.connect(self.buffer)
        self.dlg.afficher_btn.clicked.connect(self.intersection)

        self.buttons()
        if(self.dlg.comboBox.currentText() == "Sentinel-1"):
            self.dlg.comboBox_2.setEnabled(False)
            self.dlg.btn_valider_2.setCursor(
                QCursor(QtCore.Qt.ForbiddenCursor))
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
